package hr.mikrotron.bastex;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.ParseException;
import java.util.Date;


/**Parser for PDF bank statement extracted as plain text
 * @author prexy
 * @version 0.1
 */
public class BankStatementParser {

	private final String OWNER = "MIKROTRON";
	private final int MAX_TRANSACTIONS=20;	//maximum allowed number of transactions in single statement
	private Record record;
	private int cursor;	//index cursor, equals to current position in record
	private double runningBalance;
	private int descLines; //number of description lines (1-4)
	
	/**Constructor excepts raw record data generated by PDFManager 
	 * and passes it to {@link Record Record}
	 * @param rawRecord output of PDFManager's getText()
	 */
	public BankStatementParser(String rawRecord){
		record = new Record(rawRecord);
	}
	
	/**Parses bank statement and transactions data
	 * @param bankStatement bank statement to be parsed
	 * @throws ParseException if data cannot be parsed to expected type
	 * @throws IndexOutOfBoundsException if searched string is not present in records
	 */
	public void parse(BankStatement bankStatement) throws ParseException, IndexOutOfBoundsException{
		parseBankStatementData(bankStatement);
		try {
			parseTransactions(bankStatement);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**Parses bank statement related data
	 * @param bs bank statement to be parsed
	 * @throws ParseException if data cannot be parsed to expected type
	 * @throws IndexOutOfBoundsException if searched string is not present in records
	 */
	private void parseBankStatementData(BankStatement bs) throws ParseException, IndexOutOfBoundsException{
		bs.setNumber(record.asInt("Izvadak br.:", 1));
		bs.setDate(record.asDate("Datum izvatka:", 1));
		bs.setInputBalance(record.asDouble("Stanje prethodnog izvatka:", 1));
		bs.setDebitTransactionsTotal(record.asDouble("Ukupni dugovni promet na dan:",1)*-1);
		bs.setCreditTransacionsTotal(record.asDouble("Ukupni potražni promet na dan:", 1));
		bs.setOutputBalance(record.asDouble("Novo stanje:", 1));
	}
	
	private void parseTransactions(BankStatement bs) throws Exception{
		cursor=0;
		int counter=1;	//counts transactions
		runningBalance=bs.getInputBalance();	//keeps track of running balance
		boolean endOfStatement=false;	//loop control
		
		while (!endOfStatement){
			cursor=record.findTransactionStartIndex(String.valueOf(counter), cursor);	//find transaction start
			//TODO implement transaction parser
			bs.addTransaction(readTransaction(counter));
			
			System.out.println("Transakcija: " + counter + " od " + bs.getTransactionsCount());

			counter++;
			if (bs.isComplete()) endOfStatement=true;
			if (counter>MAX_TRANSACTIONS) throw new Exception("Too many transactions!");
		}
		
	}
	
	private Transaction readTransaction(int counter){
		
		cursor++;
		String IBAN = record.getRecord(cursor);
		cursor++;
		String payer = readParty();
		String recipient = payer;
		
		String tranNumber = record.getRecord(cursor);
		cursor++;
		String tranNumber2 = readLine();
		String[] ref = readReferences();
		
		String desc = readDescription();
		
		String code=readLine(9-2*descLines);
//		String exRate=readLine(3);	//exRate nema na HRK izvodima
		String exRate="";
		Date curDate;
		Date exeDate;
		
		try {
			curDate=record.asDate(cursor);
			cursor++;
			exeDate=record.asDate(cursor);
			cursor++;
		} catch (IndexOutOfBoundsException | ParseException e) {
			System.out.println("Greška kod čitanja datuma za transakciju " + tranNumber);
			return null;
		}
		
		Double amount=readAmount();
		if (amount<0) payer= OWNER; else recipient = OWNER;
		runningBalance += amount;
		//using tricks to keep 2 decimal places precision for double :-)
		runningBalance = BigDecimal.valueOf(runningBalance).setScale(2, RoundingMode.HALF_UP).doubleValue();
		
		//debug
//		System.out.println("Transakcija br. " + counter);
//		System.out.println("Platitelj: " + payer);
//		System.out.println("Primatelj: " + recipient);
//		System.out.println("Poziv platitelja  " + ref[0] + " " + ref[1]);
//		System.out.println("Poziv pprimatelja  " + ref[2] + " " + ref[3]);
//		System.out.println("Opis: " + desc);
//		System.out.println("Datum valute: " + curDate);
//		System.out.println("Datum izvršenja: " + exeDate);
//		System.out.println("Iznos: " + amount);
		
		return new Transaction(tranNumber, tranNumber2, IBAN, payer, recipient, ref[0], ref[2], 
				ref[1], ref[3], desc, code, exRate, curDate, exeDate, amount, runningBalance);
		
	}
	
	private String readLine(){
		return readLine(1);
	}
	
	private String readLine(int gap){
		String res="";
		if (record.getGap(cursor)==gap){
			res=record.getRecord(cursor);
			cursor++;
		}
		return res;
	}
	
	private String readParty(){
		String res=record.getRecord(cursor);
		cursor++;
		if (record.getGap(cursor)<5){
			res += ", " + record.getRecord(cursor);
			cursor++;
			if (record.getGap(cursor-1)==1 && record.getGap(cursor)==1){
				res += ", " + record.getRecord(cursor);
				cursor++;
			}
		}
		return res;
	}
	
	private String[] readReferences(){
		String[] res = new String[4];
		String read = record.getRecord(cursor);
		
		res[0]=read.substring(0, 4);
		if (read.length()>4) res[1]=read.substring(5);
		cursor++;
		read = record.getRecord(cursor);
		res[2]=read.substring(0, 4);
		if (read.length()>4) res[3]=read.substring(5);
		cursor++;
		
		return res;
	}
	
	private String readDescription(){
		String res = record.getRecord(cursor);
		cursor++;
		for (int i=1; i<4; i++){
			descLines=i;
			if (record.getGap(cursor)==1){
				res += record.getRecord(cursor);
				cursor++;
			}else{
				break;
			}
		}

		return res;
				
	}
	
	private Double readAmount(){
			try {
				if (record.getGap(cursor)==1) return record.asDouble(cursor)*(-1);
					else return record.asDouble(cursor);
			} catch (IndexOutOfBoundsException | ParseException e) {
				System.out.println(e.getMessage());
				return 0.0;
			}
	}
}
