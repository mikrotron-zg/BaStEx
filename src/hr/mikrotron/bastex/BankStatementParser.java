package hr.mikrotron.bastex;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.ParseException;
import java.util.Date;


/**Parser for PDF bank statement extracted as plain text
 * @author prexy
 * @version 0.1
 */
public class BankStatementParser {

	private final int MAX_TRANSACTIONS=1000;	//maximum allowed number of transactions in single statement
	private Record record;
	private int cursor;	//index cursor, equals to current position in record
	private double runningBalance;
	private int descLines; //number of description lines (1-4)
	
	/**Constructor excepts raw record data generated by PDFManager 
	 * and passes it to {@link Record Record}
	 * @param rawRecord output of PDFManager's getText()
	 */
	public BankStatementParser(String rawRecord){
		record = new Record(rawRecord);
	}
	
	/**Parses bank statement and transactions data
	 * @param bankStatement bank statement to be parsed
	 * @throws ParseException if data cannot be parsed to expected type
	 * @throws IndexOutOfBoundsException if searched string is not present in records
	 */
	public void parse(BankStatement bankStatement) throws ParseException, IndexOutOfBoundsException{
		parseBankStatementData(bankStatement);
		try {
			parseTransactions(bankStatement);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**Parses bank statement related data
	 * @param bs bank statement to be parsed
	 * @throws ParseException if data cannot be parsed to expected type
	 * @throws IndexOutOfBoundsException if searched string is not present in records
	 */
	private void parseBankStatementData(BankStatement bs) throws ParseException, IndexOutOfBoundsException{
		bs.setNumber(record.asInt("Izvadak br.:", 1));
		bs.setDate(record.asDate("Datum izvatka:", 1));
		bs.setInputBalance(record.asDouble("Stanje prethodnog izvatka:", 1));
		bs.setDebitTransactionsTotal(record.asDouble("Ukupni dugovni promet na dan:",1)*-1);
		bs.setCreditTransacionsTotal(record.asDouble("Ukupni potražni promet na dan:", 1));
		bs.setOutputBalance(record.asDouble("Novo stanje:", 1));
	}
	
	/**Parses all transactions in single bank statement and adds them to 
	 * {@link BankStatement Bank Statement}
	 * @param bs bank statement which transactions are being parsed
	 * @throws Exception if there seems to be too many transactions in single 
	 * bank statement (regulated by MAX_TRANSACTIONS constraint)
	 */
	private void parseTransactions(BankStatement bs) throws Exception{
		cursor=0;
		int counter=1;	//counts transactions
		runningBalance=bs.getInputBalance();	//keeps track of running balance
		boolean endOfStatement=false;	//loop control
		
		while (!endOfStatement){
			cursor=record.findTransactionStartIndex(String.valueOf(counter), cursor);	//find transaction start
			bs.addTransaction(readTransaction(counter));
			
			//System.out.println("Transakcija: " + counter + " od " + bs.getTransactionsCount());

			counter++;
			if (bs.isComplete()) endOfStatement=true;
			if (counter>MAX_TRANSACTIONS) throw new Exception("Too many transactions!");
		}
		
	}
	
	/**Reads data contained in single transaction
	 * @param counter ordinal number of transaction in bank statement
	 * @return {@link Transaction Transaction} object
	 */
	private Transaction readTransaction(int counter){
		
		cursor++;
		String IBAN = record.getRecord(cursor);
		cursor++;
		String payer = readParty();
		String recipient = payer;
		
		String tranNumber = record.getRecord(cursor);
		cursor++;
		String tranNumber2 = readLine();
		String[] ref = readReferences();
		
		String desc = readDescription();
		
		String code=readLine(9-2*descLines);
		double exRate=0.0; // we assume there is no exchange rate, it will be checked later
		Date curDate;
		Date exeDate;
		
		try {
			curDate=record.asDate(cursor);
			cursor++;
			exeDate=record.asDate(cursor);
			cursor++;
		} catch (IndexOutOfBoundsException | ParseException e) {
			//exception means there is exchange rate for this transaction
			try {
				exRate=record.asDouble(cursor);
				cursor++; //and now we read dates
				curDate=record.asDate(cursor);
				cursor++;
				exeDate=record.asDate(cursor);
				cursor++;
			} catch (IndexOutOfBoundsException | ParseException e1) {
				System.out.println("Greška kod čitanja datuma za transakciju " + tranNumber);
				return null;
			}
		}
		
		Double amount=readAmount();
		if (amount<0) payer= BaStEx.OWNER; else recipient = BaStEx.OWNER;
		runningBalance += amount;
		//using tricks to keep 2 decimal places precision for double :-)
		runningBalance = BigDecimal.valueOf(runningBalance).setScale(2, RoundingMode.HALF_UP).doubleValue();
		
		return new Transaction(tranNumber, tranNumber2, IBAN, payer, recipient, ref[0], ref[2], 
				ref[1], ref[3], desc, code, exRate, curDate, exeDate, amount, runningBalance);
		
	}
	
	/**Reads single line for which the gap equals to 1, i.e. there is
	 * no gap in data prior to this line
	 * @return data as String
	 */
	private String readLine(){
		return readLine(1);
	}
	
	/**Reads single line if gap equals to gap parameter passed to method
	 * @param gap odd number describing the depth of gap (1 means no gap, 3 is one skipped line, 
	 * 5 is equal to 3 skipped lines and so on)
	 * @return data as String
	 */
	private String readLine(int gap){
		String res="";
		if (record.getGap(cursor)==gap){
			res=record.getRecord(cursor);
			cursor++;
		}
		return res;
	}
	
	/**Parses and reads party data which could be payer or recipient
	 * @return name and address of party
	 */
	private String readParty(){
		String res=record.getRecord(cursor);
		cursor++;
		if (record.getGap(cursor)<5){
			res += ", " + record.getRecord(cursor);
			cursor++;
			if (record.getGap(cursor-1)==1 && record.getGap(cursor)==1){
				res += ", " + record.getRecord(cursor);
				cursor++;
			}
		}
		return res;
	}
	
	/**Reads transaction references and models
	 * @return 4-member String array containing:
	 * - at index 0 payers model
	 * - at index 1 payers reference
	 * - at index 2 recipients model
	 * - at index 3 recipients reference
	 */
	private String[] readReferences(){
		String[] res = new String[4];
		String read = record.getRecord(cursor);
		
		res[0]=read.substring(0, 4);
		if (read.length()>4) res[1]=read.substring(5);
		cursor++;
		read = record.getRecord(cursor);
		res[2]=read.substring(0, 4);
		if (read.length()>4) res[3]=read.substring(5);
		cursor++;
		
		return res;
	}
	
	/**Reads and formats transaction description
	 * @return transaction description
	 */
	private String readDescription(){
		if (record.getGap(cursor)==13) return ""; //no description!!
		String res = record.getRecord(cursor);
		descLines=1;
		cursor++;
		for (int i=1; i<4; i++){
			if (record.getGap(cursor)==1){
				res += record.getRecord(cursor);
				descLines++;
				cursor++;
			}else{
				break;
			}
		}

		return res;
				
	}
	
	/**Reads transaction amount as double and gives it negative sign if it is 
	 * debit transaction (owner of account is paying to someone)
	 * @return transaction amount
	 */
	private Double readAmount(){
			try {
				if (record.getGap(cursor)==1) return record.asDouble(cursor)*(-1);
					else return record.asDouble(cursor);
			} catch (IndexOutOfBoundsException | ParseException e) {
				System.out.println(e.getMessage());
				return 0.0;
			}
	}
}
