package hr.mikrotron.bastex;

import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Locale;

/**Reads data from extracted text and converts it to appropriate data types
 * @author prexy
 * @version 0.1
 */
public class Record {

	private String rawRecord;
	private ArrayList<String> records=new ArrayList<String>();	//all lines that contain text
	private ArrayList<Integer> gaps=new ArrayList<Integer>();	//empty lines BEFORE the line with text
	private NumberFormat nf = NumberFormat.getInstance(Locale.GERMAN);
	private DateFormat df = new SimpleDateFormat("dd.MM.yyyy");
	
	/**Constructor excepts raw record data generated by PDFManager and 
	 * passed by {@link BankStatementParser BankStatementParser} and
	 * extracts records and gaps
	 * @param rawRecord
	 */
	public Record(String rawRecord){
		this.rawRecord=rawRecord;
		extractRecords();
	}

	/**Gets record for given index
	 * @param index index of record
	 * @return record string for given index, if out of bounds, returns empty string
	 */
	public String getRecord(int index) {
		try{
			return records.get(index);
		}
		catch (IndexOutOfBoundsException iob){
			return "";
		}
	}

	/**Searches record for specified string, starting from the first record
	 * @param searchString string to find
	 * @return index of first string occurrence, or list array size if not found (forwarding 
	 * this index to <i>getRecord()</i> will throw IOB Exception
	 */
	public int getRecordIndex(String searchString){
		return getRecordIndex(searchString,0); //search from start
	}
	
	/**Searches record for specified string, starting from given index (included)
	 * @param searchString string to find
	 * @param startAt index to start search from
	 * @return index of first string occurrence, or list array size if not found (forwarding 
	 * this index to <i>getRecord()</i> will throw IOB Exception
	 */
	public int getRecordIndex(String searchString, int startAt){
		if (startAt>= records.size()) return records.size(); //start index is out of bounds
		for (int i=startAt ; i<records.size() ; i++){
			if (records.get(i).indexOf(searchString)>=0) return i;
		}
		return records.size();  //using this as arraylist index will raise IOOBexception		
	}


	public int findTransactionStartIndex(int transactionOrdinal, int startIndex) {
		// TODO Auto-generated method stub
		return 0;
	}

	
	/**Extracts lines containing text to <i>records</i> ArrayList, at the same time
	 * recording number of empty lines BEFORE each line of text and saving it to
	 * <i>gaps</i> ArrayList
	 */
	private void extractRecords(){
		int gapCounter=0;
		String strings[]=rawRecord.split("\n");
		for (int i=0 ; i<strings.length ; i++){
			if (strings[i].trim().isEmpty()){
				gapCounter++;
			}else{
				records.add(strings[i]);
				gaps.add(gapCounter);
				gapCounter=0;
			}
		}
		if (BaStEx.DEBUG) printResult();//debug only
	}
	
	private void printResult(){
		for (int i=0 ; i<records.size() ; i++){
			System.out.println("<" + i + ">   " + records.get(i) + "    [" + gaps.get(i) + "]");
		}
	}

	public double asDouble(int recordIndex) throws ParseException, IndexOutOfBoundsException{
		return nf.parse(records.get(recordIndex).trim()).doubleValue();
	}
	
	public double asDouble(String searchString, int addLines) throws IndexOutOfBoundsException, ParseException{
		return asDouble(getRecordIndex(searchString) + addLines);
	}
	
	public double asDouble(String searchString) throws IndexOutOfBoundsException, ParseException{
		return asDouble(searchString,0);
	}
	
	public int asInt(int recordIndex) throws ParseException, IndexOutOfBoundsException{
		return nf.parse(records.get(recordIndex).trim()).intValue();
	}
	
	public int asInt(String searchString, int addLines) throws IndexOutOfBoundsException, ParseException{
		return asInt(getRecordIndex(searchString) + addLines);
	}
	
	public int asInt(String searchString) throws IndexOutOfBoundsException, ParseException{
		return asInt(searchString,0);
	}
	
	public Date asDate(int recordIndex) throws ParseException, IndexOutOfBoundsException{
		return df.parse(records.get(recordIndex).trim());
	}
	
	public Date asDate(String searchString, int addLines) throws IndexOutOfBoundsException, ParseException{
		return asDate(getRecordIndex(searchString) + addLines);
	}
	
	public Date asDate(String searchString) throws IndexOutOfBoundsException, ParseException{
		return asDate(searchString, 0);
	}
}
